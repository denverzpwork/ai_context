# Конвенция AI Context Engineering

**Версия:** 0.0.2

**Дата изменения:** 2026-02-12

**Автор:** denver.zp

![xkcd: Standards](https://imgs.xkcd.com/comics/standards.png)
*xkcd #927: Как рождаются новые стандарты*


## Предпосылки появления

Сфера AI Context Engineering развивается быстро, однако почти каждый инструмент ожидает собственный формат и набор файлов.

В результате возникают повторяющиеся проблемы:

- знания привязываются к конкретному фреймворку или вендору;
- миграция между агентами становится дорогой;
- часть контекста хранится в промптах, а не в репозитории;
- автоматизация требует отдельных слоёв интерпретации.

Эта конвенция — попытка формализовать расположение и роли контекста в проекте так, чтобы инструменты могли меняться без потери воспроизводимости.

## Архитектурные цели

Модель должна обеспечивать:

1. воспроизводимость контекста;
2. переносимость между инструментами;
3. однозначный источник истины;
4. трассируемость от требования к доказательству выполнения.

Все последующие разделы описывают, какими механизмами эти свойства достигаются: структурой каталогов, типами документов, правилами авторства и производными индексами.

---

## Жизненный цикл задачи (ось модели)

Любая работа развивается линейно:

1. появляется требование (spec)
2. фиксируются ограничения (context)
3. выбирается стратегия (plan)
4. возникает фактическая реализация (implementation)
5. выполняется аудит (review)
6. формируется доказательство покрытия (tests-review)

Каталог задачи обязан позволять восстановить эту цепочку без внешних источников.

---

## Источник истины

Каноническими считаются только документы внутри `ai_context/`.

Любые индексы, выгрузки и представления являются производными и должны быть полностью восстановимы из файловой структуры.

---

## Корневая структура

```
ai_context/
  manifests.yaml
  rules/
  tasks/
  shared/
  adapters/
  README.md
```

Структура задаёт **полный максимум** возможных элементов.

Фактический обязательный набор для конкретной задачи определяется полем `complexity` в `spec.md`.

Корень обязан быть самодостаточным. Удаление внешних инструментов не должно разрушать доступ к знаниям.

---

## Группировка вокруг задачи

Задача — минимальная единица навигации и автоматизации.

Набор файлов внутри каталога отражает шаги жизненного цикла, объявленного ранее.

Каждый документ — либо вход следующего этапа, либо доказательство завершения предыдущего.

```
ai_context/tasks/<TASK-ID>/
  spec.md
  context.md
  plan.md
  implementation.md
  review.md
  tests-review.md
```

Колокация устраняет:

* расхождение предположений;
* потерю мотивации решений;
* невозможность аудита;
* расслоение промптов.

---

## Масштабирование глубины (complexity)

Не каждая работа требует одинакового уровня формализации. Набор обязательных артефактов зависит от риска.

```
complexity: trivial | normal | critical
```

| уровень  | spec | context | plan | implementation | review | tests |
| -------- | ---- | ------- | ---- | -------------- | ------ | ----- |
| trivial  | ✓    | –       | –    | ✓              | –      | –     |
| normal   | ✓    | опц     | ✓    | ✓              | кратко | ✓     |
| critical | ✓    | ✓       | ✓    | ✓              | ✓      | ✓     |

### Инвариант

Независимо от уровня всегда требуются:

1. связь с требованием;
2. объяснение фактического результата.

---

## Авторство и ответственность

Разделение определяется не удобством, а риском искажений.

### Намерение (human owned)

* `spec.md`
* `context.md`
* `plan.md`

ИИ может готовить черновики, но ввод в оборот допускается только после подтверждения инженером.

### Фактическое состояние (AI efficient)

* `implementation.md`
* `review.md`
* `tests-review.md`

Автоматизация допустима, человек выполняет функцию приёмки.

---

## spec.md

Первичное требование и точка идентификации задачи.

Документ является точкой, из которой производные системы получают:

* идентификатор;
* уровень сложности;
* статус;
* происхождение требования.

Именно здесь располагаются ключевые метаданные, включая статус и сложность.

```
kind: spec
source: jira|github|client
complexity: normal
status: active
```

Изменения возможны только в форме уточнений, а не переписывания истории.

### Статус

```
status: active | historical | obsolete
```

Изменяется через PR, как и код.

По умолчанию автоматизация работает только с `active`.

---

## context.md

Локальные знания, необходимые перед началом изменений: модули, контракты, ограничения, интеграции.

```
kind: context
```

Документ описывает именно текущую работу, а не систему целиком.

---

## plan.md

Рационализация выбранного пути между требованием и будущим кодом.

Содержит:

* стратегию;
* альтернативы;
* риски;
* влияние на данные;
* критерии завершения.

```
kind: plan
```

Может корректироваться по мере получения новой информации.

---

## implementation.md

Фиксация наблюдаемого результата.

Содержит:

* реальные структурные решения;
* отклонения от намерений;
* компромиссы;
* возникающий техдолг.

```
kind: implementation
```

Граница: здесь описывается «что есть», а не «насколько хорошо».

Рекомендуемый запрос для генерации: `shared/prompts/implementation.prompt.md`.

---

## review.md

Оценка корректности и эксплуатационных последствий.

```
kind: review
```

Отвечает на вопросы качества, конфигурации, готовности к использованию. Не дублирует описание устройства.

Рекомендуемый запрос для генерации: `shared/prompts/review.prompt.md`.

---

## tests-review.md

Инструмент реализации глобального инварианта трассируемости.

Связывает:

`требование → код → автоматические доказательства → ручные проверки`

```
kind: tests-review
```

Фиксирует покрытие, пробелы и уровень риска.

Рекомендуемый запрос для генерации: `shared/prompts/tests-review.prompt.md`.

---

## shared/

Общие шаблоны и заготовки, применимые к нескольким задачам.

```
ai_context/shared/
  prompts/
  templates/
  checklists/
```

---

## manifests.yaml (производный индекс)

Manifest формируется из канонических документов, прежде всего из метаданных, объявленных в `spec.md` и типах файлов внутри каталогов задач.

Он существует потому, что у системы есть потребители, которым нужен быстрый, нормализованный доступ.

Он появляется **после** определения канона, а не вместо него.

### Назначение

* ускоренное обнаружение;
* контроль целостности;
* выбор релевантного набора;
* воспроизводимость запусков;
* кэширование.

### Восстановимость

Удаление manifest не должно приводить к потере знаний. Он обязан пересобраться из структуры каталогов.

### Типовой фрагмент

```
documents:
  - id: TASK-123-spec
    kind: spec
    path: tasks/TASK-123/spec.md
    status: active
```

### Checksums

Если хеш не изменился — контекст считается тем же. Это основа инкрементальных пайплайнов.

---

## Прямое чтение и адаптеры

Канонические файлы допустимо использовать напрямую без промежуточных стадий подготовки.

### Зачем тогда адаптеры

Для случаев, где требуется:

* массовая обработка;
* разрешение зависимостей;
* фильтрация;
* преобразование форматов.

### Ограничения

Адаптер не имеет права:

* модифицировать источник;
* хранить собственную правду;
* дополнять знания вне репозитория.

Если ему чего‑то не хватает, меняется модель, а не проекция.

### Проверка архитектуры

Удаление любого адаптера не должно ломать рабочий процесс команды.

---

## Минимальный порог внедрения

Даже частичное применение модели приносит эффект.

Достаточно:

1. иметь `rules/`;
2. хранить задачи в отдельных каталогах;
3. поддерживать `spec` и `implementation`.

Это уже создаёт воспроизводимый фундамент для будущих агентов.
