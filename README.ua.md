# Конвенція AI Context Engineering

**Version:** 0.0.2

**Last updated:** 2026-02-12

**Author:** denver.zp

## Передумови появи

Сфера AI Context Engineering розвивається швидко, але майже кожен інструмент очікує власний формат і набір файлів.

У результаті виникають повторювані проблеми:

* знання прив’язуються до конкретного фреймворку або вендора;
* міграція між агентами стає дорогою;
* частина контексту зберігається в промптах, а не в репозиторії;
* автоматизація вимагає окремих шарів інтерпретації.

Ця конвенція є спробою формалізувати розташування та ролі контексту в проєкті так, щоб інструменти могли змінюватися без втрати відтворюваності.

Типові приклади залежності, від якої модель намагається піти:

* агент читає лише спеціальний JSON замість Markdown;
* пайплайн очікує попередньо зібраний індекс;
* логіка прийняття рішень існує тільки в історії діалогу;
* зміна платформи вимагає переписування всієї структури.

---

## Архітектурні цілі

Модель повинна гарантувати:

1. відтворюваність контексту;
2. переносимість між інструментами;
3. єдине джерело істини;
4. трасованість від вимоги до доказу виконання.

Наступні розділи описують, які механізми забезпечують ці властивості: структура каталогів, типи документів, правила авторства та похідні індекси.

---

## Життєвий цикл задачі (вісь моделі)

Будь‑яка робота розвивається лінійно:

1. з’являється вимога (spec)
2. фіксуються обмеження (context)
3. обирається стратегія (plan)
4. формується фактична реалізація (implementation)
5. проводиться аудит (review)
6. створюється доказ покриття (tests-review)

Каталог задачі повинен дозволяти відновити цей ланцюг без зовнішніх джерел.

---

## Джерело істини

Канонічними є лише документи всередині `ai_context/`.

Будь‑які індекси, експорт або проєкції є похідними та мають повністю відтворюватися зі структури файлів.

---

## Коренева структура

```
ai_context/
  manifests.yaml
  rules/
  tasks/
  shared/
  adapters/
  README.md
```

Структура визначає **максимальну оболонку** можливих елементів.

Фактичний обов’язковий набір для конкретної задачі визначається полем `complexity` у `spec.md`.

Корінь повинен бути самодостатнім. Видалення зовнішніх інструментів не має руйнувати доступ до знань.

---

## Групування навколо задачі

Задача — мінімальна одиниця навігації та автоматизації.

Набір файлів у каталозі відображає кроки життєвого циклу, визначені раніше.

Кожен документ — або вхід до наступного етапу, або доказ завершення попереднього.

```
ai_context/tasks/<TASK-ID>/
  spec.md
  context.md
  plan.md
  implementation.md
  review.md
  tests-review.md
```

Колокація усуває:

* розходження припущень;
* втрату мотивації рішень;
* неможливість аудиту;
* фрагментацію промптів.

---

## Масштабування глибини (complexity)

Не кожна зміна потребує однакового рівня формалізації. Обов’язковий набір артефактів залежить від ризику.

```
complexity: trivial | normal | critical
```

| рівень   | spec | context | plan | implementation | review  | tests |
| -------- | ---- | ------- | ---- | -------------- | ------- | ----- |
| trivial  | ✓    | –       | –    | ✓              | –       | –     |
| normal   | ✓    | опц     | ✓    | ✓              | коротко | ✓     |
| critical | ✓    | ✓       | ✓    | ✓              | ✓       | ✓     |

### Інваріант

Незалежно від рівня завжди потрібні:

1. зв’язок із вимогою;
2. пояснення фактичного результату.

---

## Авторство та відповідальність

Розділення визначається ризиком викривлень, а не зручністю.

### Намір (human owned)

* `spec.md`
* `context.md`
* `plan.md`

AI може готувати чернетки, але введення в дію потребує підтвердження інженера.

### Фактичний стан (AI efficient)

* `implementation.md`
* `review.md`
* `tests-review.md`

Автоматизація допустима; людина виконує приймання.

---

## spec.md

Первинна вимога та точка ідентичності задачі.

Документ є місцем, з якого похідні системи отримують:

* ідентифікатор;
* рівень складності;
* статус;
* походження вимоги.

Ключові метадані, включно зі статусом та складністю, зберігаються тут.

```
kind: spec
source: jira|github|client
complexity: normal
status: active
```

Зміни дозволені лише як уточнення, а не переписування історії.

### Статус

```
status: active | historical | obsolete
```

Змінюється через PR, так само як код.

За замовчуванням автоматизація працює лише з `active`.

---

## context.md

Локальні знання, необхідні перед внесенням змін: модулі, контракти, обмеження, інтеграції.

```
kind: context
```

Документ описує поточну роботу, а не всю систему.

---

## plan.md

Раціоналізація обраного шляху між вимогою та майбутнім кодом.

Містить:

* стратегію;
* альтернативи;
* ризики;
* вплив на дані;
* критерії завершення.

```
kind: plan
```

Може змінюватися з появою нової інформації.

---

## implementation.md

Фіксація спостережуваного результату.

Містить:

* реальні структурні рішення;
* відхилення від наміру;
* компроміси;
* новий технічний борг.

```
kind: implementation
```

Межа: тут описується те, що існує, а не його якість.

Рекомендований шаблон генерації: `shared/prompts/implementation.prompt.md`.

---

## review.md

Оцінка коректності та експлуатаційних наслідків.

```
kind: review
```

Відповідає на питання якості, конфігурації та готовності. Не дублює опис структури.

Рекомендований шаблон генерації: `shared/prompts/review.prompt.md`.

---

## tests-review.md

Механізм, який забезпечує глобальний інваріант трасованості.

Поєднує:

`вимога → код → автоматичний доказ → ручна перевірка`

```
kind: tests-review
```

Фіксує покриття, прогалини та рівень ризику.

Рекомендований шаблон генерації: `shared/prompts/tests-review.prompt.md`.

---

## shared/

Загальні шаблони та матеріали, придатні для кількох задач.

```
ai_context/shared/
  prompts/
  templates/
  checklists/
```

---

## manifests.yaml (похідний індекс)

Маніфест будується з канонічних документів, насамперед із метаданих у `spec.md` та типів файлів у каталогах задач.

Він існує, тому що деяким споживачам потрібен швидкий, нормалізований доступ.

Він з’являється **після** визначення канону, а не замість нього.

### Призначення

* прискорене виявлення;
* контроль цілісності;
* вибір релевантного набору;
* відтворювані запуски;
* кешування.

### Відновлюваність

Видалення маніфесту не повинно призводити до втрати знань. Він має перебудовуватися зі структури каталогів.

### Типовий фрагмент

```
documents:
  - id: TASK-123-spec
    kind: spec
    path: tasks/TASK-123/spec.md
    status: active
```

### Контрольні суми

Якщо хеш не змінився, контекст вважається ідентичним. Це основа інкрементальних пайплайнів.

---

## Пряме читання та адаптери

Канонічні файли можуть використовуватися безпосередньо без проміжних стадій підготовки.

### Навіщо існують адаптери

Для сценаріїв, що потребують:

* масової обробки;
* розв’язання залежностей;
* фільтрації;
* перетворення форматів.

### Обмеження

Адаптер не має права:

* змінювати джерело;
* підтримувати власну істину;
* збагачувати знання поза репозиторієм.

Якщо чогось бракує, змінюється модель, а не проєкція.

### Архітектурний тест

Видалення будь‑якого адаптера не повинно ламати робочий процес команди.

---

## Мінімальний поріг впровадження

Навіть часткове застосування моделі приносить користь.

Достатні умови:

1. підтримувати `rules/`;
2. зберігати задачі в ізольованих каталогах;
3. мати `spec` та `implementation`.

Це вже створює відтворювану основу для майбутніх агентів.
